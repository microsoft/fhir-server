# Pipeline to periodically clean up old AAD resources from the test tenant

trigger: none # This pipeline is intended to be run manually or on a schedule

schedules:
- cron: "0 3 * * 0" # Run every Sunday at 3 AM UTC
  displayName: Weekly AAD Cleanup
  branches:
    include:
    - main
  always: true

variables:
- template: build-variables.yml

parameters:
- name: AgeThresholdDays
  displayName: 'Age Threshold (Days) for Cleanup'
  type: number
  default: 30

stages:
- stage: CleanupAADStage
  displayName: 'Clean up AAD Test Tenant Resources'
  jobs:
  # Job 1: Delete old applications and service principals
  - job: cleanupAppsAndServicePrincipals
    displayName: 'Cleanup Old Apps and Service Principals'
    pool:
      vmImage: '$(WindowsVmImage)'
    timeoutInMinutes: 0
    steps:
    - template: jobs/aad-cleanup-steps.yml
      parameters:
        displayName: 'Remove Old AAD Applications and Service Principals'
        moduleNames:
          - Microsoft.Graph.Authentication
          - Microsoft.Graph.Beta.Applications
        AgeThresholdDays: ${{ parameters.AgeThresholdDays }}
        scriptContent: |
          # --- Cleanup Applications and Service Principals ---
          Write-Host "Starting cleanup of AAD Applications and Service Principals older than $AgeThresholdDays days matching pattern 'f[0-9]+.*'..."
          try {
              # Get all applications - Microsoft Graph doesn't support startswith in OData filter for apps
              Write-Host "Retrieving applications from Microsoft Graph API..."
              $allApps = Get-MgBetaApplication -All
              
              # Filter apps client-side using the pattern and date
              $regexPattern = '^f\d+.*' # Starts with 'f', followed by one or more digits
              Write-Host "Applying client-side filters: Regex '$regexPattern' and CreatedDateTime < $cutoffDate"
              $appsToDelete = $allApps | Where-Object { 
                  ($_.DisplayName -match $regexPattern) -and 
                  ($_.CreatedDateTime -lt $cutoffDate) 
              }

              if ($appsToDelete.Count -gt 0) {
                  Write-Host "Found $($appsToDelete.Count) applications matching the pattern and older than $cutoffDate."

                  foreach ($app in $appsToDelete) {
                      Write-Host "Processing Application: $($app.DisplayName) (AppID: $($app.AppId), ObjectID: $($app.Id), Created: $($app.CreatedDateTime))"
                      $appObjectId = $app.Id
                      $appAppId = $app.AppId
                      $appDisplayName = $app.DisplayName

                      try {
                          # Find associated Service Principal using AppId
                          $servicePrincipals = Get-MgBetaServicePrincipal -Filter "appId eq '$appAppId'" -ErrorAction SilentlyContinue
                          
                          foreach ($sp in $servicePrincipals) {
                              $spId = $sp.Id
                              Write-Host "  Found associated Service Principal: $($sp.DisplayName) (ObjectID: $spId). Attempting deletion..."
                              Remove-MgBetaServicePrincipal -ServicePrincipalId $spId -ErrorAction Stop
                              Write-Host "  Successfully deleted Service Principal (ObjectID: $spId)."
                          }

                          # Delete the Application
                          Write-Host "  Attempting to delete Application: $appDisplayName (ObjectID: $appObjectId)..."
                          Remove-MgBetaApplication -ApplicationId $appObjectId -ErrorAction Stop
                          Write-Host "  Successfully deleted Application (ObjectID: $appObjectId)."
                      } catch {
                          # Log warning but continue with the next application
                          Write-Warning "  Failed to delete Application $appDisplayName (ObjectID: $appObjectId) or its Service Principal: $($_.Exception.Message)"
                      }
                  }
              } else {
                  Write-Host "No applications matching the pattern '$regexPattern' were found older than the cutoff date ($cutoffDate)."
              }
          } catch {
              # Catch errors during application processing
              Write-Error "An error occurred while querying or processing applications: $($_.Exception.Message)"
          }
          Write-Host "Application and Service Principal cleanup finished."

  # Job 2: Delete old users
  - job: cleanupUsers
    displayName: 'Cleanup Old Users'
    pool:
      vmImage: '$(WindowsVmImage)'
    timeoutInMinutes: 0
    steps:
    - template: jobs/aad-cleanup-steps.yml
      parameters:
        displayName: 'Remove Old AAD Users'
        moduleNames:
          - Microsoft.Graph.Authentication
          - Microsoft.Graph.Beta.Users
        AgeThresholdDays: ${{ parameters.AgeThresholdDays }}
        scriptContent: |
          # --- User Cleanup ---
          Write-Host "Starting cleanup of AAD Users older than $AgeThresholdDays days matching pattern 'f[0-9]+.*'..."
          try {
              # Get users starting with 'f' and filter by UserType
              $filterQuery = "startswith(displayName,'f') and userType eq 'Member'"
              $usersStartingWithF = Get-MgBetaUser -Filter $filterQuery -All -ErrorAction SilentlyContinue
              
              if ($null -eq $usersStartingWithF -or $usersStartingWithF.Count -eq 0) {
                  Write-Host "No users found starting with 'f' and UserType 'Member'."
              } else {
                  # Apply more specific regex filter and date filter client-side
                  $userRegexPattern = '^f\d+.*' # Starts with 'f', followed by one or more digits
                  Write-Host "Applying client-side filters: Regex '$userRegexPattern' and CreatedDateTime < $cutoffDate"
                  $usersToDelete = $usersStartingWithF | Where-Object { 
                      ($_.DisplayName -match $userRegexPattern) -and 
                      ($_.CreatedDateTime -lt $cutoffDate) 
                  }

                  if ($usersToDelete.Count -gt 0) {
                      Write-Host "Found $($usersToDelete.Count) users matching the pattern and older than $cutoffDate."

                      foreach ($user in $usersToDelete) {
                          Write-Host "Processing User: $($user.DisplayName) (UPN: $($user.UserPrincipalName), ObjectID: $($user.Id), Created: $($user.CreatedDateTime))"
                          $userId = $user.Id
                          $userDisplayName = $user.DisplayName

                          try {
                              # Delete the User
                              Write-Host "  Attempting to delete User: $userDisplayName (ObjectID: $userId)..."
                              Remove-MgBetaUser -UserId $userId -ErrorAction Stop
                              Write-Host "  Successfully deleted User (ObjectID: $userId)."
                          } catch {
                              # Log warning but continue with the next user
                              Write-Warning "  Failed to delete User $userDisplayName (ObjectID: $userId): $($_.Exception.Message)"
                          }
                      }
                  } else {
                      Write-Host "No users matching the pattern '$userRegexPattern' and UserType 'Member' were found older than the cutoff date ($cutoffDate)."
                  }
              }
          } catch {
              # Catch errors during user processing
              Write-Error "An error occurred while querying or processing users: $($_.Exception.Message)"
          }
          Write-Host "User cleanup finished."

  # Job 3: Hard delete applications (depends on job 1)
  - job: hardDeleteApps
    displayName: 'Hard Delete Applications'
    dependsOn: cleanupAppsAndServicePrincipals
    pool:
      vmImage: '$(WindowsVmImage)'
    timeoutInMinutes: 0
    steps:
    - template: jobs/aad-cleanup-steps.yml
      parameters:
        displayName: 'Hard Delete AAD Applications'
        moduleNames:
          - Microsoft.Graph.Authentication
          - Microsoft.Graph.DirectoryObjects
        scriptContent: |
          # --- Hard Delete Applications ---
          Write-Host "Starting permanent deletion of AAD Applications from directory recycle bin..."
          try {
              # Get deleted applications using the correct cmdlet
              Write-Host "Retrieving deleted applications from Microsoft Graph API..."
              $deletedApps = Get-MgDirectoryDeletedItemAsApplication -All -ErrorAction SilentlyContinue
              
              if ($null -eq $deletedApps -or $deletedApps.Count -eq 0) {
                  Write-Host "No deleted applications found in the directory recycle bin."
              } else {
                  Write-Host "Found $($deletedApps.Count) deleted applications in the directory recycle bin."

                  foreach ($app in $deletedApps) {
                      $appId = $app.Id
                      $appDisplayName = $app.DisplayName
                      
                      try {
                          # Permanently delete the application from the directory recycle bin
                          Write-Host "  Attempting to permanently delete Application: $appDisplayName (ObjectID: $appId)..."
                          Remove-MgDirectoryDeletedItem -DirectoryObjectId $appId -ErrorAction Stop
                          Write-Host "  Successfully permanently deleted Application (ObjectID: $appId)."
                      } catch {
                          # Log warning but continue with the next application
                          Write-Warning "  Failed to permanently delete Application (ObjectID: $appId): $($_.Exception.Message)"
                      }
                  }
                  Write-Host "Deleted applications cleanup finished."
              }
          } catch {
              # Catch errors during deleted objects processing
              Write-Error "An error occurred while querying or processing deleted applications: $($_.Exception.Message)"
          }

  # Job 4: Hard delete service principals (depends on job 1)
  - job: hardDeleteServicePrincipals
    displayName: 'Hard Delete Service Principals'
    dependsOn: cleanupAppsAndServicePrincipals
    pool:
      vmImage: '$(WindowsVmImage)'
    timeoutInMinutes: 0
    steps:
    - template: jobs/aad-cleanup-steps.yml
      parameters:
        displayName: 'Hard Delete AAD Service Principals'
        moduleNames:
          - Microsoft.Graph.Authentication
          - Microsoft.Graph.DirectoryObjects
        scriptContent: |
          # --- Hard Delete Service Principals ---
          Write-Host "Starting permanent deletion of AAD Service Principals from directory recycle bin..."
          try {
              # Get deleted service principals
              Write-Host "Retrieving deleted service principals from Microsoft Graph API..."
              $deletedServicePrincipals = Get-MgDirectoryDeletedItemAsServicePrincipal -All -ErrorAction SilentlyContinue
              
              if ($null -eq $deletedServicePrincipals -or $deletedServicePrincipals.Count -eq 0) {
                  Write-Host "No deleted service principals found in the directory recycle bin."
              } else {
                  Write-Host "Found $($deletedServicePrincipals.Count) deleted service principals in the directory recycle bin."

                  foreach ($sp in $deletedServicePrincipals) {
                      $spId = $sp.Id
                      $spDisplayName = $sp.DisplayName
                      
                      try {
                          # Permanently delete the service principal from the directory recycle bin
                          Write-Host "  Attempting to permanently delete Service Principal: $spDisplayName (ObjectID: $spId)..."
                          Remove-MgDirectoryDeletedItem -DirectoryObjectId $spId -ErrorAction Stop
                          Write-Host "  Successfully permanently deleted Service Principal (ObjectID: $spId)."
                      } catch {
                          # Log warning but continue with the next service principal
                          Write-Warning "  Failed to permanently delete Service Principal (ObjectID: $spId): $($_.Exception.Message)"
                      }
                  }
                  Write-Host "Deleted service principals cleanup finished."
              }
          } catch {
              # Catch errors during deleted objects processing
              Write-Error "An error occurred while querying or processing deleted service principals: $($_.Exception.Message)"
          }

  # Job 5: Hard delete users (depends on job 2)
  - job: hardDeleteUsers
    displayName: 'Hard Delete Users'
    dependsOn: cleanupUsers
    pool:
      vmImage: '$(WindowsVmImage)'
    timeoutInMinutes: 0
    steps:
    - template: jobs/aad-cleanup-steps.yml
      parameters:
        displayName: 'Hard Delete AAD Users'
        moduleNames:
          - Microsoft.Graph.Authentication
          - Microsoft.Graph.DirectoryObjects
        scriptContent: |
          # --- Hard Delete Users ---
          Write-Host "Starting permanent deletion of AAD Users from directory recycle bin..."
          try {
              # Get deleted users
              Write-Host "Retrieving deleted users from Microsoft Graph API..."
              $deletedUsers = Get-MgDirectoryDeletedItemAsUser -All -ErrorAction SilentlyContinue
              
              # Filter deleted users by the same pattern used for active users
              $userRegexPattern = '^f\d+.*' # Starts with 'f', followed by one or more digits
              $filteredDeletedUsers = $deletedUsers | Where-Object { $_.DisplayName -match $userRegexPattern }
              
              if ($null -eq $filteredDeletedUsers -or $filteredDeletedUsers.Count -eq 0) {
                  Write-Host "No deleted users matching the pattern '$userRegexPattern' found in the directory recycle bin."
              } else {
                  Write-Host "Found $($filteredDeletedUsers.Count) deleted users matching the pattern in the directory recycle bin."

                  foreach ($user in $filteredDeletedUsers) {
                      $userId = $user.Id
                      $userDisplayName = $user.DisplayName
                      
                      try {
                          # Permanently delete the user from the directory recycle bin
                          Write-Host "  Attempting to permanently delete User: $userDisplayName (ObjectID: $userId)..."
                          Remove-MgDirectoryDeletedItem -DirectoryObjectId $userId -ErrorAction Stop
                          Write-Host "  Successfully permanently deleted User (ObjectID: $userId)."
                      } catch {
                          # Log warning but continue with the next user
                          Write-Warning "  Failed to permanently delete User (ObjectID: $userId): $($_.Exception.Message)"
                      }
                  }
                  Write-Host "Deleted users cleanup finished."
              }
          } catch {
              # Catch errors during deleted objects processing
              Write-Error "An error occurred while querying or processing deleted users: $($_.Exception.Message)"
          }
