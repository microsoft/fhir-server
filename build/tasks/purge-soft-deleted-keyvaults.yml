# Task template to purge soft-deleted Key Vaults
# This prevents soft-delete conflicts when deploying new vaults with the same name

steps:
- task: AzureCLI@2
  displayName: 'Purge Soft-Deleted Key Vaults'
  inputs:
    azureSubscription: $(ConnectedServiceName)
    scriptType: pscore
    scriptLocation: inlineScript
    inlineScript: |
      $keyVaultBaseName = "$(KeyVaultBaseName)"
      $region = "$(ResourceGroupRegion)"
      $pattern = "$keyVaultBaseName*"
      
      Write-Host "Looking for soft-deleted Key Vaults matching pattern: $pattern in region: $region"
      
      # Get all soft-deleted key vaults using Azure CLI (more reliable than PowerShell cmdlet)
      $deletedVaultsJson = az keyvault list-deleted --query "[?starts_with(name, '$keyVaultBaseName') && properties.location=='$region'].{name:name, location:properties.location}" -o json 2>$null
      
      if ([string]::IsNullOrEmpty($deletedVaultsJson) -or $deletedVaultsJson -eq "[]") {
        Write-Host "No soft-deleted Key Vaults found matching pattern"
        exit 0
      }
      
      $deletedVaults = $deletedVaultsJson | ConvertFrom-Json
      
      if ($null -eq $deletedVaults -or $deletedVaults.Count -eq 0) {
        Write-Host "No soft-deleted Key Vaults found matching pattern"
        exit 0
      }
      
      Write-Host "Found $($deletedVaults.Count) soft-deleted Key Vault(s) to purge in parallel"
      
      # Purge vaults in parallel using ForEach-Object -Parallel
      $purgeResults = $deletedVaults | ForEach-Object -Parallel {
        $vaultName = $_.name
        $location = $_.location
        
        try {
          $output = az keyvault purge --name $vaultName --location $location 2>&1
          if ($LASTEXITCODE -eq 0) {
            [PSCustomObject]@{ Vault = $vaultName; Status = "Purged" }
          } else {
            # Check if it's a "not found" error - vault may have already been purged
            if ($output -match "VaultNotFound|NotFound|does not exist") {
              [PSCustomObject]@{ Vault = $vaultName; Status = "AlreadyPurged" }
            } else {
              [PSCustomObject]@{ Vault = $vaultName; Status = "Failed: $output" }
            }
          }
        }
        catch {
          $errorMessage = $_.Exception.Message
          if ($errorMessage -match "VaultNotFound|NotFound|does not exist") {
            [PSCustomObject]@{ Vault = $vaultName; Status = "AlreadyPurged" }
          } else {
            [PSCustomObject]@{ Vault = $vaultName; Status = "Failed: $errorMessage" }
          }
        }
      } -ThrottleLimit 10
      
      # Report results
      $purgeResults | ForEach-Object {
        if ($_.Status -eq "Purged") {
          Write-Host "Successfully purged: $($_.Vault)"
        } elseif ($_.Status -eq "AlreadyPurged") {
          Write-Host "Vault $($_.Vault) already purged or not found - skipping"
        } else {
          Write-Warning "$($_.Vault): $($_.Status)"
        }
      }
      
      $purgedCount = ($purgeResults | Where-Object { $_.Status -eq "Purged" }).Count
      $skippedCount = ($purgeResults | Where-Object { $_.Status -eq "AlreadyPurged" }).Count
      $failedCount = ($purgeResults | Where-Object { $_.Status -like "Failed:*" }).Count
      
      Write-Host "Completed: $purgedCount purged, $skippedCount already purged, $failedCount failed"
