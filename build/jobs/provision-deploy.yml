parameters:
- name: version
  type: string
- name: sql
  type: boolean
  default: false
- name: webAppName
  type: string
- name: appServicePlanName
  type: string
- name: appServicePlanResourceGroup
  type: string
- name: subscription
  type: string
- name: resourceGroup
  type: string
- name: testEnvironmentUrl
  type: string
- name: imageTag
  type: string
- name: schemaAutomaticUpdatesEnabled
  type: string
  default: 'tool'
- name: sqlServerName
  type: string
  default: ''
- name: sqlComputeTier
  type: string
  default: 'Standard'
- name: reindexEnabled
  type: boolean
  default: true
- name: keyVaultName
  type: string
  default: ''
- name: addTriggeringUserAccess
  type: boolean
  default: false
- name: adminUserAssignedManagedIdentityName
  type: string
  default: ''

jobs:
- job: provisionEnvironment
  pool:
    name: '$(SharedLinuxPool)'
    vmImage: '$(LinuxVmImage)'
  steps:
  - task: AzureKeyVault@1
    displayName: 'Azure Key Vault: resolute-oss-tenant-info'
    inputs:
      azureSubscription: $(ConnectedServiceName)
      KeyVaultName: 'resolute-oss-tenant-info'

  - task: AzurePowerShell@5
    displayName: 'Azure PowerShell script: InlineScript'
    inputs:
      azureSubscription: $(ConnectedServiceName)
      azurePowerShellVersion: latestVersion
      ScriptType: inlineScript
      Inline: |
        Add-Type -AssemblyName System.Web

        # Import retry helper for transient error handling
        . $(System.DefaultWorkingDirectory)/release/scripts/PowerShell/Invoke-WithRetry.ps1

        # Helper function to resolve triggering user info from git commit author
        # Supports GitHub noreply emails by looking up username mapping in Key Vault
        # Key Vault secret format: "objectId|upn" (e.g., "a1b2c3d4-...|joestr@microsoft.com")
        # Returns hashtable with ObjectId and Upn properties, or $null if not found
        function Get-TriggeringUserInfo {
            try {
                # Get git commit author email
                $gitEmail = git log -1 --format='%ae' 2>$null
                if ([string]::IsNullOrEmpty($gitEmail)) {
                    Write-Host "Could not retrieve git commit author email."
                    return $null
                }
                Write-Host "Git commit author email: $gitEmail"
                
                # Check if this is a GitHub noreply email pattern: 12345+username@users.noreply.github.com
                if ($gitEmail -match '^(\d+\+)?(.+)@users\.noreply\.github\.com$') {
                    $githubUsername = $Matches[2]
                    Write-Host "Detected GitHub noreply email. Extracted username: $githubUsername"
                    
                    # Look up the Azure AD info from Key Vault secret
                    $secretName = "github-$githubUsername"
                    Write-Host "Looking up Key Vault secret: $secretName"
                    try {
                        $secret = Get-AzKeyVaultSecret -VaultName 'resolute-oss-tenant-info' -Name $secretName -AsPlainText -ErrorAction Stop
                        if (-not [string]::IsNullOrEmpty($secret)) {
                            # Parse secret format: "objectId|upn"
                            $parts = $secret -split '\|'
                            if ($parts.Count -eq 2) {
                                $result = @{
                                    ObjectId = $parts[0].Trim()
                                    Upn = $parts[1].Trim()
                                }
                                Write-Host "Found Azure AD mapping in Key Vault - ObjectId: $($result.ObjectId), UPN: $($result.Upn)"
                                return $result
                            } else {
                                Write-Warning "Key Vault secret '$secretName' has invalid format. Expected 'objectId|upn'. Skipping user provisioning."
                                return $null
                            }
                        }
                    } catch {
                        Write-Warning "Key Vault secret '$secretName' not found. To enable automatic user provisioning, create a secret named '$secretName' with format 'objectId|upn'."
                        return $null
                    }
                }
                
                # Not a noreply email - cannot resolve without Key Vault mapping
                Write-Host "Git email '$gitEmail' is not a GitHub noreply email. Key Vault mapping required for user provisioning."
                return $null
            } catch {
                Write-Warning "Error resolving triggering user info: $($_.Exception.Message)"
                return $null
            }
        }

        $deployPath = "$(System.DefaultWorkingDirectory)/test/Configuration"

        $testConfig = (ConvertFrom-Json (Get-Content -Raw "$deployPath/testconfiguration.json"))
        $flattenedTestConfig = $(System.DefaultWorkingDirectory)/release/scripts/PowerShell/ConvertTo-FlattenedConfigurationHashtable.ps1 -InputObject $testConfig

        $additionalProperties = $flattenedTestConfig

        $additionalProperties["SqlServer__DeleteAllDataOnStartup"] = "false"
        $additionalProperties["SqlServer__AllowDatabaseCreation"] = "true"
        $additionalProperties["CosmosDb__InitialDatabaseThroughput"] = 1500
        $additionalProperties["TaskHosting__PollingFrequencyInSeconds"] = 2
        $additionalProperties["ASPNETCORE_FORWARDEDHEADERS_ENABLED"] = "true"

        $webAppName = "${{ parameters.webAppName }}".ToLower()
        Write-Host "Web App Name: $webAppName"
        $templateParameters = @{
            fhirVersion = "${{ parameters.version }}"
            appServicePlanName = "${{ parameters.appServicePlanName }}"
            appServicePlanSku = "P2V3"
            numberOfInstances = 2
            serviceName = $webAppName
            keyVaultName = "${{ parameters.keyVaultName }}".ToLower()
            securityAuthenticationAuthority = "https://login.microsoftonline.com/$(tenant-id)"
            securityAuthenticationAudience = "${{ parameters.testEnvironmentUrl }}"
            additionalFhirServerConfigProperties = $additionalProperties
            enableAadSmartOnFhirProxy = $true
            enableExport = $true
            enableConvertData = $true
            enableImport = $true
            backgroundTaskCount = 4
            enableReindex = if ("${{ parameters.reindexEnabled }}" -eq "true") { $true } else { $false }
            registryName = '$(azureContainerRegistry)'
            imageTag = '${{ parameters.imageTag }}'
            isNspExisting = $true
        }

        if("${{ parameters.sql }}" -eq "true"){
            # Set SQL Variables
            $templateParameters["solutionType"] = "FhirServerSqlServer"
            $templateParameters["sqlServerName"] = "${{parameters.sqlServerName}}".ToLower()
            $templateParameters["sqlServerNewOrExisting"] = "existing"
            $templateParameters["sqlSchemaAutomaticUpdatesEnabled"] = "${{parameters.schemaAutomaticUpdatesEnabled}}"
            $templateParameters["sqlDatabaseComputeTier"] = "${{parameters.sqlComputeTier}}"
        }

        $deploymentName = $webAppName
        $resourceGroupName = "${{ parameters.resourceGroup }}"

        Write-Host "Provisioning Resource Group"
        Write-Host "ResourceGroupName: ${{ parameters.resourceGroup }}"

        # Set NSP name to match ARM template convention
        $nspName = "nsp-$resourceGroupName"
        $templateParameters["networkSecurityPerimeterName"] = $nspName

        # Check if a deployment with the specified name already exists
        $existingDeployment = Get-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue

        # If the deployment exists and is ongoing, wait for it to complete
        if ($existingDeployment -and ($existingDeployment.ProvisioningState -eq "Running" -or $existingDeployment.ProvisioningState -eq "Accepted")) {
            Write-Host "Waiting for existing deployment '$deploymentName' to complete..."
            do {
                Start-Sleep -Seconds 10
                $existingDeployment = Get-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName
            } while ($existingDeployment.ProvisioningState -eq "Running" -or $existingDeployment.ProvisioningState -eq "Accepted")
            Write-Host "Existing deployment completed."
        }
        else
        {
          try {
            New-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-azuredeploy-docker.json -TemplateParameterObject $templateParameters -Verbose
          } catch {
            if ("${{ parameters.sql }}" -eq "true") {
              $templateParameters["sqlServerNewOrExisting"] = "new"
              New-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-azuredeploy-docker.json -TemplateParameterObject $templateParameters -Verbose
            }
          }
        }

        if("${{ parameters.sql }}" -eq "false"){
            Write-Host "Add DevOps MI permission to Cosmos database"

            $account = Get-AzContext

            # Retry Get-AzADServicePrincipal for AAD replication delays
            $principalId = Invoke-WithRetry -OperationName "Get Service Principal" -ScriptBlock {
                (Get-AzADServicePrincipal -ApplicationId $account.Account.Id -ErrorAction Stop).Id
            }

            # Retry CosmosDB role assignment for resource propagation delays
            Invoke-WithRetry -OperationName "CosmosDB Role Assignment" -ScriptBlock {
                New-AzCosmosDBSqlRoleAssignment `
                  -AccountName $webAppName `
                  -ResourceGroupName $resourceGroupName `
                  -Scope "/" `
                  -PrincipalId $principalId `
                  -RoleDefinitionId "00000000-0000-0000-0000-000000000002" `
                  -ErrorAction Stop
            }

            # Add triggering user access to CosmosDB if enabled
            if ("${{ parameters.addTriggeringUserAccess }}" -eq "true") {
                $userInfo = Get-TriggeringUserInfo
                
                if ($userInfo -and -not [string]::IsNullOrEmpty($userInfo.ObjectId)) {
                    Write-Host "Adding triggering user (ObjectId: $($userInfo.ObjectId)) to CosmosDB..."
                    try {
                        Invoke-WithRetry -OperationName "Add Triggering User CosmosDB Role" -ScriptBlock {
                            New-AzCosmosDBSqlRoleAssignment `
                              -AccountName $webAppName `
                              -ResourceGroupName $resourceGroupName `
                              -Scope "/" `
                              -PrincipalId $userInfo.ObjectId `
                              -RoleDefinitionId "00000000-0000-0000-0000-000000000002" `
                              -ErrorAction Stop
                        }
                        Write-Host "Successfully added triggering user to CosmosDB with Data Contributor role"
                    } catch {
                        if ($_.Exception.Message -like "*RoleAssignmentAlreadyExists*" -or $_.Exception.Message -like "*already exists*") {
                            Write-Host "Triggering user already has CosmosDB access. Skipping."
                        } else {
                            Write-Warning "Could not add triggering user to CosmosDB: $($_.Exception.Message). Continuing pipeline."
                        }
                    }
                } else {
                    Write-Host "No triggering user info resolved. Skipping CosmosDB user provisioning."
                }
            }

            # Associate CosmosDB with Network Security Perimeter using external template
            Write-Host "Associating CosmosDB with Network Security Perimeter: $nspName"
            
            $associationName = "cosmosdb-$webAppName-association"
                
            Write-Host "Creating NSP association using external ARM template..."
            Write-Host "NSP Name: $nspName"
            Write-Host "CosmosDB Account: $webAppName"
            Write-Host "Association Name: $associationName"
                
            $nspTemplateParameters = @{
                'nspName' = $nspName
                'resourceName' = $webAppName
                'resourceType' = 'Microsoft.DocumentDB/databaseAccounts'
                'associationName' = $associationName
                'accessMode' = 'Learning'
                'nspProfile' = 'default'
            }
                
            # Retry NSP association deployment for resource propagation delays
            $nspDeploymentResult = Invoke-WithRetry -OperationName "NSP Association Deployment" -ScriptBlock {
                New-AzResourceGroupDeployment `
                  -ResourceGroupName $resourceGroupName `
                  -Name "$webAppName-cosmosdb-nsp-association" `
                  -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/nsp-resource-association.json `
                  -TemplateParameterObject $nspTemplateParameters `
                  -Verbose `
                  -ErrorAction Stop
            }
                
            Write-Host "Successfully associated CosmosDB with NSP using external ARM template"
            Write-Host "Association Resource ID: $($nspDeploymentResult.Outputs.associationResourceId.Value)"
        }

        if("${{ parameters.sql }}" -eq "true"){
            # Add triggering user access to SQL database if enabled
            if ("${{ parameters.addTriggeringUserAccess }}" -eq "true") {
                $userInfo = Get-TriggeringUserInfo
                $adminUamiName = "${{ parameters.adminUserAssignedManagedIdentityName }}"
                
                if ($userInfo -and -not [string]::IsNullOrEmpty($userInfo.Upn) -and -not [string]::IsNullOrEmpty($adminUamiName)) {
                    $triggeringUserUpn = $userInfo.Upn
                    Write-Host "Adding triggering user '$triggeringUserUpn' to SQL database..."
                    
                    # Install SqlServer module if not available
                    if (-not (Get-Module -ListAvailable -Name SqlServer)) {
                        Write-Host "Installing SqlServer module..."
                        Install-Module -Name SqlServer -Force -Scope CurrentUser -AllowClobber
                    }
                    Import-Module SqlServer
                    
                    $sqlServerName = "${{parameters.sqlServerName}}".ToLower()
                    $databaseName = "FHIR_${{ parameters.version }}"
                    
                    # Get service connection info (App ID and Tenant ID for ARM template)
                    $serviceConnectionAppId = (Get-AzContext).Account.Id
                    $serviceConnectionTenantId = (Get-AzContext).Tenant.Id
                    $serviceConnectionDisplayName = "$(ConnectedServiceName) - $serviceConnectionAppId"
                    Write-Host "Service connection AppId: $serviceConnectionAppId, TenantId: $serviceConnectionTenantId"
                    
                    # Get UAMI info for restoring admin later
                    $uami = Get-AzUserAssignedIdentity -Name $adminUamiName -ResourceGroupName $resourceGroupName
                    $uamiPrincipalId = $uami.PrincipalId
                    $uamiTenantId = $uami.TenantId
                    Write-Host "UAMI '$adminUamiName' PrincipalId: $uamiPrincipalId, TenantId: $uamiTenantId"
                    
                    try {
                        # Temporarily set service connection as SQL admin using ARM template
                        # This approach works for cross-tenant service principals
                        Write-Host "Setting service connection as SQL admin via ARM template..."
                        $serviceConnectionAdminParams = @{
                            sqlServerName = $sqlServerName
                            sqlAdministratorLogin = $serviceConnectionDisplayName
                            sqlAdministratorSid = $serviceConnectionAppId
                            sqlAdministratorTenantId = $serviceConnectionTenantId
                            sqlServerPrincipalType = "Application"
                        }
                        
                        Invoke-WithRetry -OperationName "Set Service Connection as SQL Admin" -ScriptBlock {
                            New-AzResourceGroupDeployment `
                              -ResourceGroupName $resourceGroupName `
                              -Name "$sqlServerName-admin-swap-to-sc" `
                              -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-sqlServer.json `
                              -TemplateParameterObject $serviceConnectionAdminParams `
                              -ErrorAction Stop
                        }
                        
                        # Wait for admin change to propagate (30 seconds for AAD replication)
                        Write-Host "Waiting 30 seconds for SQL admin change to propagate..."
                        Start-Sleep -Seconds 30
                        
                        # Create SQL user for the triggering user with db_owner role
                        $sqlQuery = "IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = N'$triggeringUserUpn') "
                        $sqlQuery += "BEGIN "
                        $sqlQuery += "CREATE USER [$triggeringUserUpn] FROM EXTERNAL PROVIDER; "
                        $sqlQuery += "ALTER ROLE db_owner ADD MEMBER [$triggeringUserUpn]; "
                        $sqlQuery += "PRINT 'Created user and added to db_owner role'; "
                        $sqlQuery += "END "
                        $sqlQuery += "ELSE BEGIN "
                        $sqlQuery += "IF NOT EXISTS (SELECT 1 FROM sys.database_role_members drm "
                        $sqlQuery += "JOIN sys.database_principals dp ON drm.member_principal_id = dp.principal_id "
                        $sqlQuery += "JOIN sys.database_principals r ON drm.role_principal_id = r.principal_id "
                        $sqlQuery += "WHERE dp.name = N'$triggeringUserUpn' AND r.name = 'db_owner') "
                        $sqlQuery += "BEGIN ALTER ROLE db_owner ADD MEMBER [$triggeringUserUpn]; PRINT 'Added existing user to db_owner role'; END "
                        $sqlQuery += "ELSE BEGIN PRINT 'User already exists with db_owner role'; END "
                        $sqlQuery += "END"
                        
                        # Get fresh access token inside retry block and execute SQL
                        Invoke-WithRetry -OperationName "Add Triggering User to SQL" -ScriptBlock {
                            # Get fresh token with explicit tenant to avoid cache issues
                            $freshToken = (Get-AzAccessToken -ResourceUrl "https://database.windows.net/" -TenantId $serviceConnectionTenantId).Token
                            Write-Host "Connecting to: $sqlServerName.database.windows.net, Database: $databaseName"
                            Write-Host "Token acquired, length: $($freshToken.Length)"
                            
                            Invoke-Sqlcmd `
                              -ServerInstance "$sqlServerName.database.windows.net" `
                              -Database $databaseName `
                              -AccessToken $freshToken `
                              -Query $sqlQuery `
                              -ErrorAction Stop
                        }
                        
                        Write-Host "Successfully added triggering user to SQL database with db_owner role"
                    } catch {
                        Write-Warning "Could not add triggering user to SQL database: $($_.Exception.Message). Continuing pipeline."
                    } finally {
                        # Always restore UAMI as SQL admin using ARM template
                        Write-Host "Restoring UAMI '$adminUamiName' as SQL admin via ARM template..."
                        try {
                            $uamiAdminParams = @{
                                sqlServerName = $sqlServerName
                                sqlAdministratorLogin = $uamiPrincipalId
                                sqlAdministratorSid = $uamiPrincipalId
                                sqlAdministratorTenantId = $uamiTenantId
                                sqlServerPrincipalType = "User"
                            }
                            
                            Invoke-WithRetry -OperationName "Restore UAMI as SQL Admin" -ScriptBlock {
                                New-AzResourceGroupDeployment `
                                  -ResourceGroupName $resourceGroupName `
                                  -Name "$sqlServerName-admin-swap-to-uami" `
                                  -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-sqlServer.json `
                                  -TemplateParameterObject $uamiAdminParams `
                                  -ErrorAction Stop
                            }
                            Write-Host "Successfully restored UAMI as SQL admin"
                        } catch {
                            Write-Error "CRITICAL: Failed to restore UAMI as SQL admin: $($_.Exception.Message)"
                        }
                    }
                } elseif ([string]::IsNullOrEmpty($adminUamiName)) {
                    Write-Host "adminUserAssignedManagedIdentityName not provided. Skipping SQL user provisioning."
                } else {
                    Write-Host "No triggering user info resolved. Skipping SQL user provisioning."
                }
            }
        }
  - template: ./provision-healthcheck.yml
    parameters:
      webAppName: ${{ parameters.webAppName }}
