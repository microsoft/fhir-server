parameters:
- name: version
  type: string
- name: sql
  type: boolean
  default: false
- name: webAppName
  type: string
- name: appServicePlanName
  type: string
- name: appServicePlanResourceGroup
  type: string
- name: subscription
  type: string
- name: resourceGroup
  type: string
- name: testEnvironmentUrl
  type: string
- name: imageTag
  type: string
- name: schemaAutomaticUpdatesEnabled
  type: string
  default: 'tool'
- name: sqlServerName
  type: string
  default: ''
- name: sqlComputeTier
  type: string
  default: 'Standard'
- name: reindexEnabled
  type: boolean
  default: true
- name: keyVaultName
  type: string
  default: ''
- name: addTriggeringUserAccess
  type: boolean
  default: false

jobs:
- job: provisionEnvironment
  pool:
    name: '$(SharedLinuxPool)'
    vmImage: '$(LinuxVmImage)'
  steps:
  - task: AzureKeyVault@1
    displayName: 'Azure Key Vault: resolute-oss-tenant-info'
    inputs:
      azureSubscription: $(ConnectedServiceName)
      KeyVaultName: 'resolute-oss-tenant-info'

  - task: AzurePowerShell@5
    displayName: 'Azure PowerShell script: InlineScript'
    inputs:
      azureSubscription: $(ConnectedServiceName)
      azurePowerShellVersion: latestVersion
      ScriptType: inlineScript
      Inline: |
        Add-Type -AssemblyName System.Web

        # Import retry helper for transient error handling
        . $(System.DefaultWorkingDirectory)/release/scripts/PowerShell/Invoke-WithRetry.ps1

        $deployPath = "$(System.DefaultWorkingDirectory)/test/Configuration"

        $testConfig = (ConvertFrom-Json (Get-Content -Raw "$deployPath/testconfiguration.json"))
        $flattenedTestConfig = $(System.DefaultWorkingDirectory)/release/scripts/PowerShell/ConvertTo-FlattenedConfigurationHashtable.ps1 -InputObject $testConfig

        $additionalProperties = $flattenedTestConfig

        $additionalProperties["SqlServer__DeleteAllDataOnStartup"] = "false"
        $additionalProperties["SqlServer__AllowDatabaseCreation"] = "true"
        $additionalProperties["CosmosDb__InitialDatabaseThroughput"] = 1500
        $additionalProperties["TaskHosting__PollingFrequencyInSeconds"] = 2
        $additionalProperties["ASPNETCORE_FORWARDEDHEADERS_ENABLED"] = "true"

        $webAppName = "${{ parameters.webAppName }}".ToLower()
        Write-Host "Web App Name: $webAppName"
        $templateParameters = @{
            fhirVersion = "${{ parameters.version }}"
            appServicePlanName = "${{ parameters.appServicePlanName }}"
            appServicePlanSku = "P2V3"
            numberOfInstances = 2
            serviceName = $webAppName
            keyVaultName = "${{ parameters.keyVaultName }}".ToLower()
            securityAuthenticationAuthority = "https://login.microsoftonline.com/$(tenant-id)"
            securityAuthenticationAudience = "${{ parameters.testEnvironmentUrl }}"
            additionalFhirServerConfigProperties = $additionalProperties
            enableAadSmartOnFhirProxy = $true
            enableExport = $true
            enableConvertData = $true
            enableImport = $true
            backgroundTaskCount = 4
            enableReindex = if ("${{ parameters.reindexEnabled }}" -eq "true") { $true } else { $false }
            registryName = '$(azureContainerRegistry)'
            imageTag = '${{ parameters.imageTag }}'
            isNspExisting = $true
        }

        if("${{ parameters.sql }}" -eq "true"){
            # Set SQL Variables
            $templateParameters["solutionType"] = "FhirServerSqlServer"
            $templateParameters["sqlServerName"] = "${{parameters.sqlServerName}}".ToLower()
            $templateParameters["sqlServerNewOrExisting"] = "existing"
            $templateParameters["sqlSchemaAutomaticUpdatesEnabled"] = "${{parameters.schemaAutomaticUpdatesEnabled}}"
            $templateParameters["sqlDatabaseComputeTier"] = "${{parameters.sqlComputeTier}}"
        }

        $deploymentName = $webAppName
        $resourceGroupName = "${{ parameters.resourceGroup }}"

        Write-Host "Provisioning Resource Group"
        Write-Host "ResourceGroupName: ${{ parameters.resourceGroup }}"

        # Set NSP name to match ARM template convention
        $nspName = "nsp-$resourceGroupName"
        $templateParameters["networkSecurityPerimeterName"] = $nspName

        # Check if a deployment with the specified name already exists
        $existingDeployment = Get-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -ErrorAction SilentlyContinue

        # If the deployment exists and is ongoing, wait for it to complete
        if ($existingDeployment -and ($existingDeployment.ProvisioningState -eq "Running" -or $existingDeployment.ProvisioningState -eq "Accepted")) {
            Write-Host "Waiting for existing deployment '$deploymentName' to complete..."
            do {
                Start-Sleep -Seconds 10
                $existingDeployment = Get-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName
            } while ($existingDeployment.ProvisioningState -eq "Running" -or $existingDeployment.ProvisioningState -eq "Accepted")
            Write-Host "Existing deployment completed."
        }
        else
        {
          try {
            New-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-azuredeploy-docker.json -TemplateParameterObject $templateParameters -Verbose
          } catch {
            if ("${{ parameters.sql }}" -eq "true") {
              $templateParameters["sqlServerNewOrExisting"] = "new"
              New-AzResourceGroupDeployment -Name $deploymentName -ResourceGroupName $resourceGroupName -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-azuredeploy-docker.json -TemplateParameterObject $templateParameters -Verbose
            }
          }
        }

        if("${{ parameters.sql }}" -eq "false"){
            Write-Host "Add DevOps MI permission to Cosmos database"

            $account = Get-AzContext

            # Retry Get-AzADServicePrincipal for AAD replication delays
            $principalId = Invoke-WithRetry -OperationName "Get Service Principal" -ScriptBlock {
                (Get-AzADServicePrincipal -ApplicationId $account.Account.Id -ErrorAction Stop).Id
            }

            # Retry CosmosDB role assignment for resource propagation delays
            Invoke-WithRetry -OperationName "CosmosDB Role Assignment" -ScriptBlock {
                New-AzCosmosDBSqlRoleAssignment `
                  -AccountName $webAppName `
                  -ResourceGroupName $resourceGroupName `
                  -Scope "/" `
                  -PrincipalId $principalId `
                  -RoleDefinitionId "00000000-0000-0000-0000-000000000002" `
                  -ErrorAction Stop
            }

            # Add triggering user access to CosmosDB if enabled
            if ("${{ parameters.addTriggeringUserAccess }}" -eq "true") {
                $triggeringUserEmail = "$(Build.RequestedForEmail)"
                
                # For PR/automated triggers, email may be empty - get from git commit author
                if ([string]::IsNullOrEmpty($triggeringUserEmail)) {
                    Write-Host "Build.RequestedForEmail not available, getting email from git commit author..."
                    try {
                        $gitAuthorEmail = git log -1 --format='%ae' 2>$null
                        if (-not [string]::IsNullOrEmpty($gitAuthorEmail)) {
                            $triggeringUserEmail = $gitAuthorEmail
                            Write-Host "Found git commit author email: $triggeringUserEmail"
                        }
                    } catch {
                        Write-Warning "Could not get git commit author email: $($_.Exception.Message)"
                    }
                }
                
                if (-not [string]::IsNullOrEmpty($triggeringUserEmail)) {
                    Write-Host "Adding triggering user '$triggeringUserEmail' to CosmosDB..."
                    try {
                        $userPrincipal = Get-AzADUser -UserPrincipalName $triggeringUserEmail -ErrorAction SilentlyContinue
                        if (-not $userPrincipal) {
                            # Try by mail attribute for guest users
                            $userPrincipal = Get-AzADUser -Filter "mail eq '$triggeringUserEmail'" -ErrorAction SilentlyContinue
                        }
                        if ($userPrincipal) {
                            Invoke-WithRetry -OperationName "Add Triggering User CosmosDB Role" -ScriptBlock {
                                New-AzCosmosDBSqlRoleAssignment `
                                  -AccountName $webAppName `
                                  -ResourceGroupName $resourceGroupName `
                                  -Scope "/" `
                                  -PrincipalId $userPrincipal.Id `
                                  -RoleDefinitionId "00000000-0000-0000-0000-000000000002" `
                                  -ErrorAction Stop
                            }
                            Write-Host "Successfully added triggering user to CosmosDB with Data Contributor role"
                        } else {
                            Write-Warning "Could not find user '$triggeringUserEmail' in Azure AD. Skipping CosmosDB user provisioning."
                        }
                    } catch {
                        if ($_.Exception.Message -like "*RoleAssignmentAlreadyExists*" -or $_.Exception.Message -like "*already exists*") {
                            Write-Host "Triggering user already has CosmosDB access. Skipping."
                        } else {
                            Write-Warning "Could not add triggering user to CosmosDB: $($_.Exception.Message). Continuing pipeline."
                        }
                    }
                } else {
                    Write-Host "No triggering user email available. Skipping CosmosDB user provisioning."
                }
            }

            # Associate CosmosDB with Network Security Perimeter using external template
            Write-Host "Associating CosmosDB with Network Security Perimeter: $nspName"
            
            $associationName = "cosmosdb-$webAppName-association"
                
            Write-Host "Creating NSP association using external ARM template..."
            Write-Host "NSP Name: $nspName"
            Write-Host "CosmosDB Account: $webAppName"
            Write-Host "Association Name: $associationName"
                
            $nspTemplateParameters = @{
                'nspName' = $nspName
                'resourceName' = $webAppName
                'resourceType' = 'Microsoft.DocumentDB/databaseAccounts'
                'associationName' = $associationName
                'accessMode' = 'Learning'
                'nspProfile' = 'default'
            }
                
            # Retry NSP association deployment for resource propagation delays
            $nspDeploymentResult = Invoke-WithRetry -OperationName "NSP Association Deployment" -ScriptBlock {
                New-AzResourceGroupDeployment `
                  -ResourceGroupName $resourceGroupName `
                  -Name "$webAppName-cosmosdb-nsp-association" `
                  -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/nsp-resource-association.json `
                  -TemplateParameterObject $nspTemplateParameters `
                  -Verbose `
                  -ErrorAction Stop
            }
                
            Write-Host "Successfully associated CosmosDB with NSP using external ARM template"
            Write-Host "Association Resource ID: $($nspDeploymentResult.Outputs.associationResourceId.Value)"
        }

        if("${{ parameters.sql }}" -eq "true"){
            # Add triggering user access to SQL database if enabled
            if ("${{ parameters.addTriggeringUserAccess }}" -eq "true") {
                $triggeringUserEmail = "$(Build.RequestedForEmail)"
                
                # For PR/automated triggers, email may be empty - get from git commit author
                if ([string]::IsNullOrEmpty($triggeringUserEmail)) {
                    Write-Host "Build.RequestedForEmail not available, getting email from git commit author..."
                    try {
                        $gitAuthorEmail = git log -1 --format='%ae' 2>$null
                        if (-not [string]::IsNullOrEmpty($gitAuthorEmail)) {
                            $triggeringUserEmail = $gitAuthorEmail
                            Write-Host "Found git commit author email: $triggeringUserEmail"
                        }
                    } catch {
                        Write-Warning "Could not get git commit author email: $($_.Exception.Message)"
                    }
                }
                
                if (-not [string]::IsNullOrEmpty($triggeringUserEmail)) {
                    Write-Host "Adding triggering user '$triggeringUserEmail' to SQL database..."
                    try {
                        $sqlServerName = "${{parameters.sqlServerName}}".ToLower()
                        $databaseName = "FHIR_${{ parameters.version }}"
                        
                        # Get access token for SQL using the current Azure context
                        $accessToken = (Get-AzAccessToken -ResourceUrl "https://database.windows.net/").Token
                        
                        # Create SQL user for the triggering user with db_owner role
                        # Using string concatenation to avoid YAML heredoc parsing issues
                        $sqlQuery = "IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = N'$triggeringUserEmail') "
                        $sqlQuery += "BEGIN "
                        $sqlQuery += "CREATE USER [$triggeringUserEmail] FROM EXTERNAL PROVIDER; "
                        $sqlQuery += "ALTER ROLE db_owner ADD MEMBER [$triggeringUserEmail]; "
                        $sqlQuery += "PRINT 'Created user and added to db_owner role'; "
                        $sqlQuery += "END "
                        $sqlQuery += "ELSE BEGIN "
                        $sqlQuery += "IF NOT EXISTS (SELECT 1 FROM sys.database_role_members drm "
                        $sqlQuery += "JOIN sys.database_principals dp ON drm.member_principal_id = dp.principal_id "
                        $sqlQuery += "JOIN sys.database_principals r ON drm.role_principal_id = r.principal_id "
                        $sqlQuery += "WHERE dp.name = N'$triggeringUserEmail' AND r.name = 'db_owner') "
                        $sqlQuery += "BEGIN ALTER ROLE db_owner ADD MEMBER [$triggeringUserEmail]; PRINT 'Added existing user to db_owner role'; END "
                        $sqlQuery += "ELSE BEGIN PRINT 'User already exists with db_owner role'; END "
                        $sqlQuery += "END"
                        
                        Invoke-WithRetry -OperationName "Add Triggering User to SQL" -ScriptBlock {
                            Invoke-Sqlcmd `
                              -ServerInstance "$sqlServerName.database.windows.net" `
                              -Database $databaseName `
                              -AccessToken $accessToken `
                              -Query $sqlQuery `
                              -ErrorAction Stop
                        }
                        
                        Write-Host "Successfully added triggering user to SQL database with db_owner role"
                    } catch {
                        Write-Warning "Could not add triggering user to SQL database: $($_.Exception.Message). Continuing pipeline."
                    }
                } else {
                    Write-Host "No triggering user email available. Skipping SQL user provisioning."
                }
            }
        }
  - template: ./provision-healthcheck.yml
    parameters:
      webAppName: ${{ parameters.webAppName }}
