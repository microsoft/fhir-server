parameters:
- name: resourceGroup
  type: string
- name: sqlServerName
  type: string
- name: adminType
  type: string
  values:
  - userAssignedManagedIdentity
  - federatedServiceConnection
- name: adminUserAssignedManagedIdentityName
  type: string
  default: ''
- name: deploymentName
  type: string
  default: ''
- name: nspName
  type: string
  default: ''

jobs:
- job: 'provisionSql_${{ parameters.deploymentName }}'
  pool:
    name: '$(SharedLinuxPool)'
    vmImage: '$(LinuxVmImage)'
  steps:
  - task: AzurePowerShell@5
    displayName: 'Azure PowerShell script: InlineScript'
    inputs:
      azureSubscription: $(ConnectedServiceName)
      azurePowerShellVersion: latestVersion
      ScriptType: inlineScript
      Inline: |
        Add-Type -AssemblyName System.Web

        $adminUserAssignedManagedIdentityName = "${{ parameters.adminUserAssignedManagedIdentityName }}"
        $adminType = "${{ parameters.adminType }}"
        $resourceGroup = "${{ parameters.resourceGroup }}"
        $sqlServerName = "${{ parameters.sqlServerName }}".ToLower()
        $nspName = "${{ parameters.nspName }}"

        if ($adminType -eq "userAssignedManagedIdentity" -and $adminUserAssignedManagedIdentityName -eq "") {
          Write-Error "adminUserAssignedManagedIdentityName must be provided when adminType is userAssignedManagedIdentity."
          exit 1
        }

        if ($adminType -eq "userAssignedManagedIdentity") {
          # Get the location of the resource group
          $resourceGroupDetails = Get-AzResourceGroup -Name $resourceGroup
          $location = $resourceGroupDetails.Location

          # Create user-assigned managed identity
          $identity = New-AzUserAssignedIdentity -ResourceGroupName $resourceGroup -Name $adminUserAssignedManagedIdentityName -Location $location

          $principalId = $identity.PrincipalId
          $tenantId = $identity.TenantId
          $templateParameters = @{
              sqlServerName = $sqlServerName 
              sqlAdministratorLogin = $principalId
              sqlAdministratorSid = $principalId
              sqlAdministratorTenantId = $tenantId
              sqlServerPrincipalType = "User"
          }
        }

        if ($adminType -eq "federatedServiceConnection") {
          $clientId = (Get-AzContext).Account.Id
          $tenantId = (Get-AzContext).Tenant.Id

          $templateParameters = @{
              sqlServerName = $sqlServerName 
              sqlAdministratorLogin = "$(ConnectedServiceName) - $clientId"
              sqlAdministratorSid = $clientId
              sqlAdministratorTenantId = $tenantId
              sqlServerPrincipalType = "Application"
          }
        }

        Write-Host "Provisioning Sql server"
        Write-Host "Resource Group: ${{ parameters.resourceGroup }}"
        Write-Host "SqlServerName: ${{ parameters.sqlServerName }}"
        New-AzResourceGroupDeployment -ResourceGroupName "${{ parameters.resourceGroup }}" -Name "${{ parameters.sqlServerName }}-deploy" -TemplateFile $(System.DefaultWorkingDirectory)/samples/templates/default-sqlServer.json -TemplateParameterObject $templateParameters -Verbose

        $agentIP = (New-Object net.webclient).downloadstring("https://api.ipify.org")
        New-AzSqlServerFirewallRule -ResourceGroupName $resourceGroup -ServerName $sqlServerName -FirewallRuleName "AzureDevopsAgent" -StartIPAddress $agentIp -EndIPAddress $agentIP

        # Associate SQL Server with Network Security Perimeter if NSP name is provided
        if (-not [string]::IsNullOrEmpty($nspName)) {
          Write-Host "Associating SQL Server with Network Security Perimeter: $nspName"
          
          try {
            # Get the SQL Server resource ID
            $sqlServer = Get-AzSqlServer -ResourceGroupName $resourceGroup -ServerName $sqlServerName
            $sqlServerResourceId = $sqlServer.ResourceId
            
            Write-Host "SQL Server Resource ID: $sqlServerResourceId"
            
            # Get subscription and create association name
            $subscriptionId = (Get-AzContext).Subscription.Id
            $associationName = "sqlserver-$sqlServerName-association"
            
            Write-Host "Subscription ID: $subscriptionId"
            Write-Host "Resource Group: $resourceGroup"
            Write-Host "NSP Name: $nspName"
            Write-Host "Association Name: $associationName"
            
            # Try using Azure CLI instead of REST API as it might be more reliable
            $azCliInstalled = Get-Command az -ErrorAction SilentlyContinue
            if ($azCliInstalled) {
              Write-Host "Using Azure CLI for NSP association"
              
              # First, try to create the association using Azure CLI
              $cliCommand = "az network perimeter association create --perimeter-name '$nspName' --resource-group '$resourceGroup' --name '$associationName' --private-link-resource '$sqlServerResourceId' --profile 'default'"
              Write-Host "CLI Command: $cliCommand"
              
              $result = Invoke-Expression $cliCommand 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Successfully associated SQL Server with NSP using Azure CLI"
                Write-Host "CLI Result: $result"
              } else {
                Write-Warning "Azure CLI association failed: $result"
                throw "Azure CLI association failed"
              }
            } else {
              Write-Host "Azure CLI not available, attempting REST API approach"
              
              # Fallback to REST API with corrected approach
              $associationBody = @{
                properties = @{
                  privateLinkResource = @{
                    id = $sqlServerResourceId
                  }
                  profile = @{
                    id = "/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Network/networkSecurityPerimeters/$nspName/profiles/default"
                  }
                }
              } | ConvertTo-Json -Depth 4
              
              $apiVersion = "2023-07-01-preview"
              $uri = [System.Uri]::new("https://management.azure.com/subscriptions/$subscriptionId/resourceGroups/$resourceGroup/providers/Microsoft.Network/networkSecurityPerimeters/$nspName/resourceAssociations/$associationName" + "?api-version=$apiVersion")
              
              Write-Host "REST API URI: $($uri.ToString())"
              Write-Host "Association Body: $associationBody"
              
              # Get access token
              $accessToken = (Get-AzAccessToken).Token
              
              $headers = @{
                'Authorization' = "Bearer $accessToken"
                'Content-Type' = 'application/json'
              }
              
              Write-Host "Creating NSP association via REST API..."
              $response = Invoke-RestMethod -Uri $uri.ToString() -Method PUT -Body $associationBody -Headers $headers
              
              Write-Host "Successfully associated SQL Server with NSP via REST API"
              Write-Host "Association Response: $($response | ConvertTo-Json -Depth 3)"
            }
          }
          catch {
            Write-Warning "Failed to associate SQL Server with NSP: $($_.Exception.Message)"
            Write-Host "Exception Details: $($_.Exception | Format-List * | Out-String)"
            if ($_.Exception.Response) {
              Write-Host "HTTP Response Status: $($_.Exception.Response.StatusCode)"
              try {
                $responseContent = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($responseContent)
                $responseText = $reader.ReadToEnd()
                Write-Host "HTTP Response Content: $responseText"
              } catch {
                Write-Host "Could not read response content"
              }
            }
            Write-Host "Continuing with SQL Server provisioning..."
          }
        }
        else {
          Write-Host "No NSP name provided, skipping NSP association"
        }
